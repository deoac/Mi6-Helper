#!/usr/bin/env raku

use App::Mi6;

use LibGit2;
use JSON::Fast;
use Config::INI;

=begin comment
use File::Find;
use JSON::Fast;
use Text::Utils;
=end comment

my $dir = @*ARGS.shift;
die "FATAL: Path '$dir' is not a directory."
    unless $dir.IO.d;
say "Using directory '$dir' as the target module directory.";

try my $repo = Git::Repository.open: $dir;
if not $repo {
    say qq:to/HERE/;
    FATAL: Directory '$dir' is not a Git repository.
           Retry with a directory which is.
    HERE
    exit;
}

# get status
my %new;
my %indexed;
my %unknown;
for $repo.status-each {
    my $n = .path;
    my $s = .status;
    if $s ~~ /WT_NEW/ {
        %new{$n} = 1;
    }
    elsif $s ~~ /INDEX/ {
        %indexed{$n} = 1;
    }
    else {
        %unknown{$n} = $s;
    }
}

# all is ok iif no elements in the three hashes
my $err = 0;
say "On branch ?";
if %indexed.elems {
    ++$err;
    say "Changes to be committed:";
    say '  (use "git reset HEAD <file>..." to unstage)';
    say();
    say "\tnew file:   $_" for %indexed.keys.sort;
    say();
}
if %new.elems {
    ++$err;
    say "Untracked files:";
    say '  (use "git add <file>..." to include in what will be committed)';
    say();
    say "\t$_" for %new.keys.sort;
    say();
}
if %unknown.elems {
    ++$err;
    say "Files with unhandled status:";
    say();
    for %unknown.keys.sort {
        my $v = %unknown{$_};
        say "  $_ => $v";
    }
    say();
}
if $err {
    say q:to/HERE/;
    No changes will be made until you have committed 
      or '.gitignor'ed all listed files.
    HERE
    say();
    #say "Exiting now...";
    #exit;
}

# check for fez
say();
say "Checking for a fez account...";;
my $fezfil = "%*ENV<HOME>/.fez-config.json";
my $feznam;
if $fezfil.IO.r {
    $feznam = %(from-json(slurp $fezfil))<un>;
    say "Found fez user name '$feznam'";
    # check for an installed fez
    my $module = 'Fez::CLI';
    try require ::($module);
    if ::($module) ~~ Failure {
        say 'You must install fez: "$ zef install fez"';
    }
}
else {
    ++$err;
    say q:to/HERE/
    No fez config file found. This program cannot 
      completely function without a fez account.
      You must install fez first. Then execute 
      '$ fez register' and follow the instructions.
    HERE
}

# check for META6.json and critical data
my $metafil = "$dir/META6.json";
my %meta;
if $metafil.IO.r {
    %meta = %((slurp $metafil).from-json);
}
else {
    ++$err;
    say "No 'META6.json' file found. One will be created.";
}

# check for module name
my $modnam = %meta<name>:exists ?? %meta<name> !! '';
if not $modnam {
    # Can we use an App::Mi6 instance?
    # Not easily.
    $modnam = find-module-name $dir;
}

# check for all dependencies
# find all files with extensions:
#    <raku rakumod rakutest> # preferred extensions
#    <p6 pl pm pm6 t>        # deprecated extensions

=finish

exit;

# var defined in BEGIN block at the end
my $test-yml;

# files required by mi6
my %fmi6 = [
    'dist.ini' => 'ini',
    'Changes'  => 'ini',
    '.github/workflows/test.yml' => 'yaml|yml',
];

# files suggested to remove
my %frem = set <
    .travis.yml
    Makefile
>;

# files to be replaced
my %frep = set <
>;

# files to be modified
my %fmod = set <
    dist.ini
    Changes
    META6.json
>;

if !@*ARGS.elems {
    say qq:to/HERE/;
    Usage: {$*PROGRAM.basename} <git module dir to check>

    NOTE: using dir '$dir' during development.

    HERE
    exit;
}

=begin pod

What am I trying to accomplish?

- Convert an existing module to use App::Mi6

- Process in order

sub check-git
  - ensure there is a .git file
    - throw if not
  - check if needing a commit
    - throw if not

  # From this point, all changes to existing files should
  # protected by Git and new files will listed as untracked.
  # If the user fails to add the files or commit them,
  # mi6 will catch the errors upon build or release.

sub get-mod-name
  - determine the base module name
    - check any dist.ini file
    - check the META6.json file
    - throw if not found or there are conflicts

sub get-mod-type
  - determine whether it's a module or a class (affects the type
    of load test)

sub check-mi6-files
  - check for missing files required by mi6
    - write my version
  - remove the dummy test created by mi6, if any

sub check-my-std-test-files
  - check for and create missing standard
    tests I use
    - Test::Meta
    - load or class test

sub find-external-mods-used
  - determine external modules used by the module being analyzed

sub write-meta6-json
  - rewrite the META6.json file (create a backup copy)
    - ensure depends and test depends are correct

sub write-dist-ini
  - rewrite the dist.ini file (create a backup copy)
    - IMPORTANT ensure the convert to pod is turned OFF until manually changed

  - check for the Unicode Copyright symbol [Copyright  &#x00A9; 2020 <author>] in the source pod
    for the README.md file
    - report results

  - use prompts where need be

=end pod

check-git $dir;

my @fils = find :$dir, :type<file>, :exclude(/'.precomp'|'.git/'/), :keep-going;
say "Files in dir '$dir'";
my %fils;
for @fils -> $fil {
    my $f = $fil.basename;
    # record all files and dups
    if %fils{$f}:exists {
        %fils{$f}.append: $fil;
    }
    else {
        %fils{$f} = [];
        %fils{$f}.append: $fil;
    }


    next if $fil ~~ /'.raku'$/;
    next if $fil ~~ /'.class'$/;

    next if %fi{$f}:exists;

    if %fmod{$f}:exists {
        print "== candidate for mods: ";
    }
    elsif %frem{$f}:exists {
        print "== candidate for removal: ";
    }
    print "$f => $fil";
    say();;
}

# find necessary used modules
my %modules = find-modules $dir, :$debug;

# check out META6.json
my %meta6 = read-meta6-json $dir, :$debug;

# check out dist.ini
my %distini = read-dist-ini $dir, :$debug;


#### SUBROUTINES ####
#| sub check-git
#|   - ensure there is a .git file
#|     - throw if not
#|   - check if needing a commit
#|     - throw if not
sub check-git($dir, :$debug) {
    # use LibGit2
    try my $repo = Git::Repository.open: $dir;
    if not $repo {
        say "FATAL: No .git subdir in dir: $dir";
        exit;
    }
    # check for uncommited or untracked files
}

sub read-dist-ini($dir, :$debug) {
    my %dist;
    my $inifil = find :dir($dir), :name<dist.ini>;
    return %dist if not $inifil;

    %dist   = Config::INI::parse(slurp $inifil);
    return %dist;
}

sub write-basic-tests($dir, $mod-name) {
    my $t1 = '000-meta-test.t';
    my $t2 = '001-load-tests.t';
    # check for existing files
    my @fils = find :$dir, :name(/'.' [t|rakutest] $/);
    .say for @fils;
}

sub find-modules($dir, :$debug) {
    # collect local as well as externally used modules
    my @fils = find :$dir, :name(/'.' [rakumod|pm6|pm] $/);

    my %modules; # key: <loc|ext>
    #                       {module-colon-name} = <file-name> = # relative to the primary module's repo dir
    #                                           = 0 # for external modules
 
    for @fils -> $mfil is copy {
        say "  Found local module: $mfil" if $debug;
    }

    return %modules;
}

sub read-meta6-json($dir, :$debug) {
    my $mfil = find :$dir, :name<META6.json>;
    say("DEBUG: found meta file: $mfil") if 1 or $debug;
    my %meta6 = from-json(slurp $mfil);
    if 1 or $debug {
        #say "DEBUG: meta6.json:";
        for %meta6.keys.sort -> $k {
            say $k;
            my $v = %meta6{$k};
            # may be hash or list or string or num
            #say "DEBUG: value type: {$v.^name}";
            if $v ~~ Str|Num {
                say(" $v");
            }
            elsif $v ~~ List {
                say(" $_") for $v;
            }
            elsif $v ~~ Hash {
                say(" $_ = '{$v{$_}}'") for $v.keys.sort;
            }
        }
    }
    return %meta6;
}

sub mod-dist-ini(%distini, :$debug) {
    if 1 or $debug {
        #say "DEBUG: dist.ini:";
        for %distini.keys.sort -> $k {
            next if $k eq '_';

            say "[$k]";
            my $v = %distini{$k};
            # may be hash or list
            #say "DEBUG: value type: {$v.^name}";
            if $v ~~ List {
                say(" $_") for $v;
            }
            elsif $v ~~ Hash {
                say(" $_ = '{$v{$_}}'") for $v.keys.sort;
            }
        }
    }
}

BEGIN {
# my file sources
$test-yml = q:to/HERE/;
# @tbrowder's version
# modded from mi6's version
name: test
on:
  push:
    branches:
      - '*'
    tags-ignore:
      - '*'
  pull_request:
jobs:
  raku:
    strategy:
      matrix:
        os:
          - ubuntu-latest
          #- macOS-latest
          #- windows-latest
        raku-version:
          - "2020.07"
          - "2019.11"
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - uses: Raku/setup-raku@v1
      - run: raku -V
      - name: Install dependencies
        run: |
          # install and test if need be (includes [test-depends])
          zef install .
          #zef install --/test --deps-only .
          zef install --/test App::Prove6
      - name: Run tests
        run: prove6 -l t
HERE
}
