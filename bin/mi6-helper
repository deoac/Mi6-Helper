#!/usr/bin/env raku

use lib <lib ../lib>;

use LibGit2;
use App::Mi6;
use Config::INI;
use File::Find;
use JSON::Fast;
use Text::Utils;

# var defined in BEGIN block at the end
my $test-yml;

# files required by mi6
my %fmi6 = [
    'dist.ini' => 'ini',
    'Changes'  => 'ini',
    '.github/workflows/test.yml' => 'yaml|yml',
];

# files required by tbrowder
my %ft = set <
    000-test-meta.t
    001-basic.t
>;

# files to remove
my %frem = set <
    .travis.yml
    Makefile
>;

# files to be replaced
my %frep = set <
>;

# files to be modified
my %fmod = set <
    dist.ini
    Changes
    META6.json
>;

# files to ignore in reports
my %fi = set <
    LICENSE
    .gitignore
>;

# tmp until ready
my $dir = find :dir(".."), :name<AVL-Tree>;
if !@*ARGS.elems {
    say qq:to/HERE/;
    Usage: {$*PROGRAM.basename} <git module dir to check>

    NOTE: using dir '$dir' during development.

    HERE
    exit;
}

my $debug = 0;

#my $dir = @*ARGS.shift;
$dir .= IO.absolute;

=begin pod

What am I trying to accomplish?

- Convert an existing module to use App::Mi6

- Process in order

sub check-git
  - ensure there is a .git file
    - throw if not
  - check if needing a commit
    - throw if not

  # From this point, all changes to existing files should
  # protected by Git and new files will listed as untracked.
  # If the user fails to add the files or commit them,
  # mi6 will cath the errors upon build or release.

sub get-mod-name
  - determine the base module name
    - check any dist.ini file
    - check the META6.json file
    - throw if not found or there are conflicts

sub get-mod-type
  - determine whether it's a module or a class (affects the type
    of load test)

sub check-mi6-files
  - check for missing files required by mi6
    - write my version
  - remove the dummy test created by mi6, if any

sub check-my-std-test-files
  - check for and create missing standard
    tests I use
    - Test::Meta
    - load or class test

sub find-external-mods-used
  - determine external modules used by the module being analyzed

sub write-meta6-json
  - rewrite the META6.json file (create a backup copy)
    - ensure depends and test depends are correct

sub write-dist-ini
  - rewrite the dist.ini file (create a backup copy)
    - IMPORTANT ensure the convert to pod is turned OFF until manually changed

  - check for the Unicode Copyright symbol [Copyright  &#x00A9; 2020 <author>] in the source pod
    for the README.md file
    - report results

  - use prompts where need be

=end pod

check-git $dir;

my @fils = find :$dir, :type<file>, :exclude(/'.precomp'|'.git/'/), :keep-going;
say "Files in dir '$dir'";
my %fils;
for @fils -> $fil {
    my $f = $fil.basename;
    # record all files and dups
    if %fils{$f}:exists {
        %fils{$f}.append: $fil;
    }
    else {
        %fils{$f} = [];
        %fils{$f}.append: $fil;
    }


    next if $fil ~~ /'.raku'$/;
    next if $fil ~~ /'.class'$/;

    next if %fi{$f}:exists;

    if %fmod{$f}:exists {
        print "== candidate for mods: ";
    }
    elsif %frem{$f}:exists {
        print "== candidate for removal: ";
    }
    print "$f => $fil";
    say();;
}

# find necessary used modules
my %modules = find-modules $dir, :$debug;

# check out META6.json
my %meta6 = read-meta6-json $dir, :$debug;

# check out dist.ini
my %distini = read-dist-ini $dir, :$debug;


#### SUBROUTINES ####
#| sub check-git
#|   - ensure there is a .git file
#|     - throw if not
#|   - check if needing a commit
#|     - throw if not
sub check-git($dir, :$debug) {
    # use LibGit2
    try my $repo = Git::Repository.open: $dir;
    if not $repo {
        say "FATAL: No .git subdir in dir: $dir";
        exit;
    }
    # check for uncommited or untracked files
}

sub read-dist-ini($dir, :$debug) {
    my %dist;
    my $inifil = find :dir($dir), :name<dist.ini>;
    return %dist if not $inifil;

    %dist   = Config::INI::parse(slurp $inifil);
    return %dist;
}

sub write-basic-tests($dir, $mod-name) {
    my $t1 = '000-meta-test.t';
    my $t2 = '001-load-tests.t';
    # check for existing files
    my @fils = find :$dir, :name(/'.' [t|rakutest] $/);
    .say for @fils;
}

sub find-modules($dir, :$debug) {
    # collect local as well as externally used modules
    my @fils = find :$dir, :name(/'.' [rakumod|pm6|pm] $/);

    my %modules; # key: <loc|ext>
    #                       {module-colon-name} = <file-name> = # relative to the primary module's repo dir
    #                                           = 0 # for external modules
 
    for @fils -> $mfil is copy {
        say "  Found local module: $mfil" if $debug;
    }

    return %modules;
}

sub read-meta6-json($dir, :$debug) {
    my $mfil = find :$dir, :name<META6.json>;
    say("DEBUG: found meta file: $mfil") if 1 or $debug;
    my %meta6 = from-json(slurp $mfil);
    if 1 or $debug {
        #say "DEBUG: meta6.json:";
        for %meta6.keys.sort -> $k {
            say $k;
            my $v = %meta6{$k};
            # may be hash or list or string or num
            #say "DEBUG: value type: {$v.^name}";
            if $v ~~ Str|Num {
                say(" $v");
            }
            elsif $v ~~ List {
                say(" $_") for $v;
            }
            elsif $v ~~ Hash {
                say(" $_ = '{$v{$_}}'") for $v.keys.sort;
            }
        }
    }
    return %meta6;
}

sub mod-dist-ini(%distini, :$debug) {
    if 1 or $debug {
        #say "DEBUG: dist.ini:";
        for %distini.keys.sort -> $k {
            next if $k eq '_';

            say "[$k]";
            my $v = %distini{$k};
            # may be hash or list
            #say "DEBUG: value type: {$v.^name}";
            if $v ~~ List {
                say(" $_") for $v;
            }
            elsif $v ~~ Hash {
                say(" $_ = '{$v{$_}}'") for $v.keys.sort;
            }
        }
    }
}

BEGIN {
# my file sources
$test-yml = q:to/HERE/;
# @tbrowder's version
# modded from mi6's version
name: test
on:
  push:
    branches:
      - '*'
    tags-ignore:
      - '*'
  pull_request:
jobs:
  raku:
    strategy:
      matrix:
        os:
          - ubuntu-latest
          #- macOS-latest
          #- windows-latest
        raku-version:
          - "2020.07"
          - "2019.11"
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v2
      - uses: Raku/setup-raku@v1
      - run: raku -V
      - name: Install dependencies
        run: |
          # install and test if need be (includes [test-depends])
          zef install .
          #zef install --/test --deps-only .
          zef install --/test App::Prove6
      - name: Run tests
        run: prove6 -l t
HERE
}
